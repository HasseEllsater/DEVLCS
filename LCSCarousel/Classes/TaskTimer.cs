using System;
using System.Collections;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;

// ReSharper disable once CheckNamespace
namespace IKriv.Threading.Tasks
{
    /// <summary>
    /// Represents running task timer, a disposable infinite series of tasks
    /// </summary>
    /// <remarks>Task timer must be disposed (stopped) in the end of the usage. 
    /// In can be enumerated only once. Attempting second enumeration will cause an 
    /// InvalidOperationException.</remarks>
    public interface ITaskTimer : IDisposable, IEnumerable<Task>
    {
    }

    /// <summary>
    /// Generates a series of tasks that get completed on timer
    /// </summary>
    /// <remarks>Use TaskTimer to perform timer-based activities in asynchronous code.
    /// Await on each generated task in order.</remarks>
    public class TaskTimer
    {
        private readonly TimeSpan _period;
        private CancellationToken _cancellationToken = CancellationToken.None;

        /// <summary>
        /// Creates new timer with a given period in seconds
        /// </summary>
        /// <param name="periodMs">Timer period in milliseconds</param>
        /// <remarks>Use one of the Start() overloads to start the timer</remarks>
        public TaskTimer(int periodMs)
        {
            _period = TimeSpan.FromMilliseconds(periodMs);
        }

        /// <summary>
        /// Creates new timer with a given period
        /// </summary>
        /// <param name="period">Timer period</param>
        /// <remarks>Use one of the Start() overloads to start the timer</remarks>
        public TaskTimer(TimeSpan period)
        {
            _period = period;
        }

        /// <summary>
        /// Sets cancellation token for the timer
        /// </summary>
        /// <param name="token">Cancellation token</param>
        /// <returns>When signaled, the token will cancel all tasks in the series generated by the timer</returns>
        public TaskTimer CancelWith(CancellationToken token)
        {
            _cancellationToken = token;
            return this;
        }

        /// <summary>
        /// Starts the timer and returns a series of tasks
        /// </summary>
        /// <param name="delayMs">Delay in milliseconds before first task in the series becomes completed</param>
        /// <returns>Infinite series of tasks completed on timer one after the other.</returns>
        public ITaskTimer Start(int delayMs = 0)
        {
            return Start(TimeSpan.FromMilliseconds(delayMs));
        }

        /// <summary>
        /// Starts the timer and returns a series of tasks
        /// </summary>
        /// <param name="delay">Delay before first task in the series becomes completed</param>
        /// <returns>Infinite series of tasks completed on timer one after the other</returns>
        public ITaskTimer Start(TimeSpan delay)
        {
            Func<Action, IDisposable> createTimer = callback => new Timer(state => callback(), null, delay, _period);
            return StartOnTimer(createTimer);
        }

        /// <summary>
        /// Starts the timer at specific time and returns a series of tasks
        /// </summary>
        /// <param name="when">Absolute time when the first task in the series becomes completed</param>
        /// <returns>Infinite series of tasks completed on timer one after the other</returns>
        public ITaskTimer StartAt(DateTime when)
        {
            var delay = when - DateTime.UtcNow;
            return Start(delay);
        }

        /// <summary>
        /// Starts the timer using custom timer object
        /// </summary>
        /// <param name="createTimer">Function that accepts callback delegate and creates a timer object</param>
        /// <returns>This overload is used for tests and custom scenarios. The object created by createTimer()
        /// should invoke the callback delegate on a periodic basis. When it does, the next task in the series
        /// will be marked as completed.</returns>
        public ITaskTimer StartOnTimer(Func<Action, IDisposable> createTimer)
        {
            return new DisposableEnumerable(new TaskTimerImpl(createTimer, _cancellationToken));
        }

        private class DisposableEnumerable : ITaskTimer
        {
            private readonly TaskTimerImpl _impl;
            private IEnumerable<Task> _tasks;

            public DisposableEnumerable(TaskTimerImpl impl)
            {
                _impl = impl;
            }

            public IEnumerator<Task> GetEnumerator()
            {
                if (_tasks != null) throw new InvalidOperationException("Timer cannot be enumerated twice");
                _tasks = _impl.GetTasks();
                return _tasks.GetEnumerator();
            }

            IEnumerator IEnumerable.GetEnumerator()
            {
                return GetEnumerator();
            }

            public void Dispose()
            {
                _impl.Dispose();
            }
        }

        private class TaskTimerImpl : IDisposable
        {
            private readonly Queue<Record> _pendingTasks = new Queue<Record>();
            private readonly IDisposable _timer;
            private long _ticks;
            private long _nTasks;
            private bool _isCanceled;

            private struct Void
            {
                public static readonly Void Value = new Void();
            }

            private struct Record
            {
                public long Tick;
                public TaskCompletionSource<Void> Promise;
            }

            public TaskTimerImpl(Func<Action, IDisposable> createTimer, CancellationToken token)
            {
                _timer = createTimer(OnTimer);
                token.Register(Cancel);
            }

            private void OnTimer()
            {
                var toComplete = new List<TaskCompletionSource<Void>>();

                lock (_pendingTasks)
                {
                    ++_ticks;
                    while (_pendingTasks.Count > 0)
                    {
                        var next = _pendingTasks.Peek();
                        if (next.Tick <= _ticks)
                        {
                            toComplete.Add(_pendingTasks.Dequeue().Promise);
                        }
                        else
                        {
                            break;
                        }
                    }
                }

                foreach (var promise in toComplete) promise.SetResult(default(Void));
            }

            public IEnumerable<Task> GetTasks()
            {
                while (true)
                {
                    yield return NextTask();
                }
                // ReSharper disable once IteratorNeverReturns
            }

            public void Dispose()
            {
                _timer.Dispose();
            }

            private Task NextTask()
            {
                lock (_pendingTasks)
                {
                    var tick = ++_nTasks;
                    bool isLate = tick <= _ticks;

                    if (_isCanceled) return CreateCanceledTask();

                    if (isLate)
                    {
                        return Task.FromResult(Void.Value);
                    }
                    else
                    {
                        var promise = new TaskCompletionSource<Void>();
                        _pendingTasks.Enqueue(new Record {Tick = tick, Promise = promise});
                        return promise.Task;
                    }
                }
            }

            private void Cancel()
            {
                lock (_pendingTasks)
                {
                    _isCanceled = true;
                    foreach (var record in _pendingTasks)
                    {
                        record.Promise.TrySetCanceled();
                    }
                }
            }

            private static Task CreateCanceledTask()
            {
                var promise = new TaskCompletionSource<Void>();
                promise.TrySetCanceled();
                return promise.Task;
            }
        }
    }
}
